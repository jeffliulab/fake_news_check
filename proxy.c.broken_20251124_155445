// CS112 Final Project Part 1 - HTTPS MITM Proxy with Flask LLM Integration

#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>
#include <pthread.h>
#include <signal.h>
#include <errno.h>
#include <sys/select.h>
#include <fcntl.h>
#include <time.h>
#include <sys/stat.h>
#include <sys/types.h>
// openssl libraries
#include <openssl/ssl.h>
#include <openssl/err.h>
#include <openssl/x509.h>
#include <openssl/x509v3.h>
#include <openssl/pem.h>
#include <openssl/rsa.h>
#include <openssl/evp.h>

#define BUFFER_SIZE 65536
#define MAX_HEADER_SIZE 8192
#define BACKLOG 128
#define FLASK_HOST "127.0.0.1"
#define FLASK_PORT 5000
#define MAX_RESPONSE_SIZE (1024 * 1024 * 10)  // 10MB max response

// global CA certificate and key
static X509 *ca_cert = NULL;
static EVP_PKEY *ca_key = NULL;

// global flag to enable/disable LLM functionality
static int llm_enabled = 0;

// Flask availability flag
static int flask_available = 1;
static time_t last_flask_check = 0;

// client connection context
typedef struct {
    int client_fd;
    struct sockaddr_in client_addr;
} client_context_t;

// function prototypes
void *handle_client(void *arg);
void handle_http_request(int client_fd, char *request, size_t req_len);
void handle_https_connect(int client_fd, char *request, size_t req_len);
int connect_to_server(const char *hostname, int port);
X509 *generate_cert(const char *hostname);
SSL_CTX *create_ssl_context_server(void);
SSL_CTX *create_ssl_context_client(void);
void inject_header(char *response, size_t *response_len, size_t buffer_size);
int read_line(int fd, char *buf, size_t max_len);
void parse_host_port(char *host_header, char **hostname, int *port);
int load_ca_cert_and_key(const char *cert_path, const char *key_path);
// Flask communication functions
char *send_to_flask_enhance(const char *html, const char *url, size_t *out_len);
int is_html_content_type(const char *content_type);
char *extract_content_type(const char *headers);

// signal handler
void signal_handler(int sig) {
    if (sig == SIGPIPE) {
        return;
    }
}

int main(int argc, char *argv[]) {
    if (argc < 4 || argc > 5) {
        fprintf(stderr, "Usage: %s <port> <ca_cert_path> <ca_key_path> [llm=true]\n", argv[0]);
        fprintf(stderr, "  Optional: llm=true to enable LLM functionality\n");
        exit(EXIT_FAILURE);
    }

    int port = atoi(argv[1]);
    const char *ca_cert_path = argv[2];
    const char *ca_key_path = argv[3];
    
    // parse optional llm parameter
    if (argc == 5) {
        if (strcmp(argv[4], "llm=true") == 0) {
            llm_enabled = 1;
            printf("‚úÖ LLM ÂäüËÉΩÂ∑≤ÂêØÁî®\n");
        } else {
            llm_enabled = 0;
            printf("‚è≠Ô∏è  LLM ÂäüËÉΩÂ∑≤Á¶ÅÁî®\n");
        }
    } else {
        llm_enabled = 0;
        printf("‚è≠Ô∏è  LLM ÂäüËÉΩÊú™ÂêØÁî® (ÈªòËÆ§)\n");
    }

    // load CA certificate and key
    if (load_ca_cert_and_key(ca_cert_path, ca_key_path) != 0) {
        fprintf(stderr, "Failed to load CA certificate and key\n");
        exit(EXIT_FAILURE);
    }

    // initialize OpenSSL
    SSL_library_init();
    SSL_load_error_strings();
    OpenSSL_add_all_algorithms();

    signal(SIGPIPE, signal_handler);

    // create listening socket
    int listen_fd = socket(AF_INET, SOCK_STREAM, 0);
    if (listen_fd < 0) {
        perror("socket");
        exit(EXIT_FAILURE);
    }

    int opt = 1;
    if (setsockopt(listen_fd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt)) < 0) {
        perror("setsockopt");
        close(listen_fd);
        exit(EXIT_FAILURE);
    }

    // bind socket
    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = INADDR_ANY;
    server_addr.sin_port = htons(port);

    if (bind(listen_fd, (struct sockaddr *)&server_addr, sizeof(server_addr)) < 0) {
        perror("bind");
        close(listen_fd);
        exit(EXIT_FAILURE);
    }

    if (listen(listen_fd, BACKLOG) < 0) {
        perror("listen");
        close(listen_fd);
        exit(EXIT_FAILURE);
    }

    printf("Proxy server listening on port %d\n", port);
    fflush(stdout);

    // main loop
    while (1) {
        struct sockaddr_in client_addr;
        socklen_t client_len = sizeof(client_addr);
        int client_fd = accept(listen_fd, (struct sockaddr *)&client_addr, &client_len);

        if (client_fd < 0) {
            perror("accept");
            continue;
        }

        client_context_t *ctx = malloc(sizeof(client_context_t));
        if (!ctx) {
            close(client_fd);
            continue;
        }
        ctx->client_fd = client_fd;
        ctx->client_addr = client_addr;

        pthread_t thread;
        pthread_attr_t attr;
        pthread_attr_init(&attr);
        pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
        
        if (pthread_create(&thread, &attr, handle_client, ctx) != 0) {
            perror("pthread_create");
            close(client_fd);
            free(ctx);
        }
        pthread_attr_destroy(&attr);
    }

    close(listen_fd);
    X509_free(ca_cert);
    EVP_PKEY_free(ca_key);
    return 0;
}

// load CA certificate and key
int load_ca_cert_and_key(const char *cert_path, const char *key_path) {
    FILE *fp = fopen(cert_path, "r");
    if (!fp) {
        perror("fopen ca_cert");
        return -1;
    }
    ca_cert = PEM_read_X509(fp, NULL, NULL, NULL);
    fclose(fp);
    if (!ca_cert) {
        fprintf(stderr, "Failed to read CA certificate\n");
        return -1;
    }

    fp = fopen(key_path, "r");
    if (!fp) {
        perror("fopen ca_key");
        X509_free(ca_cert);
        ca_cert = NULL;
        return -1;
    }
    ca_key = PEM_read_PrivateKey(fp, NULL, NULL, NULL);
    fclose(fp);
    if (!ca_key) {
        fprintf(stderr, "Failed to read CA key\n");
        X509_free(ca_cert);
        ca_cert = NULL;
        return -1;
    }

    return 0;
}

// handle client connection
void *handle_client(void *arg) {
    client_context_t *ctx = (client_context_t *)arg;
    int client_fd = ctx->client_fd;
    free(ctx);

    char request[BUFFER_SIZE];
    ssize_t req_len = recv(client_fd, request, sizeof(request) - 1, 0);
    if (req_len <= 0) {
        close(client_fd);
        return NULL;
    }
    request[req_len] = '\0';

    // check if CONNECT or regular HTTP request
    if (strncmp(request, "CONNECT ", 8) == 0) {
        handle_https_connect(client_fd, request, req_len);
    } else {
        handle_http_request(client_fd, request, req_len);
    }

    return NULL;
}

// handle regular HTTP request
void handle_http_request(int client_fd, char *request, size_t req_len) {
    char method[16], url[2048], version[16];
    char hostname[256] = {0};
    int port = 80;
    char *host_line = NULL;

    if (sscanf(request, "%15s %2047s %15s", method, url, version) != 3) {
        const char *err = "HTTP/1.1 400 Bad Request\r\n\r\n";
        send(client_fd, err, strlen(err), 0);
        close(client_fd);
        return;
    }

    // extract hostname from Host header
    host_line = strstr(request, "Host: ");
    if (host_line) {
        host_line += 6;
        char *end = strstr(host_line, "\r\n");
        if (end) {
            size_t len = end - host_line;
            if (len < sizeof(hostname)) {
                strncpy(hostname, host_line, len);
                hostname[len] = '\0';
                
                // parse port if present
                char *colon = strchr(hostname, ':');
                if (colon) {
                    *colon = '\0';
                    port = atoi(colon + 1);
                }
            }
        }
    }

    if (hostname[0] == '\0') {
        const char *err = "HTTP/1.1 400 Bad Request\r\n\r\n";
        send(client_fd, err, strlen(err), 0);
        close(client_fd);
        return;
    }

    // connect to the target server
    int server_fd = connect_to_server(hostname, port);
    if (server_fd < 0) {
        const char *err = "HTTP/1.1 502 Bad Gateway\r\n\r\n";
        send(client_fd, err, strlen(err), 0);
        close(client_fd);
        return;
    }

    // forward request to server
    ssize_t sent = 0;
    while (sent < (ssize_t)req_len) {
        ssize_t n = send(server_fd, request + sent, req_len - sent, 0);
        if (n < 0) {
            close(server_fd);
            close(client_fd);
            return;
        }
        sent += n;
    }

    // receive response and inject X-Proxy header
    char response[BUFFER_SIZE];
    int first_chunk = 1;
    
    while (1) {
        ssize_t bytes = recv(server_fd, response, sizeof(response), 0);
        if (bytes <= 0) {
            break;
        }
        
        size_t response_len = bytes;
        
        // inject X-Proxy header in first chunk
        if (first_chunk && bytes >= 5 && strncmp(response, "HTTP/", 5) == 0) {
            inject_header(response, &response_len, sizeof(response));
            first_chunk = 0;
        }
        
        ssize_t sent_to_client = 0;
        while (sent_to_client < (ssize_t)response_len) {
            ssize_t n = send(client_fd, response + sent_to_client, 
                           response_len - sent_to_client, 0);
            if (n < 0) {
                close(server_fd);
                close(client_fd);
                return;
            }
            sent_to_client += n;
        }
    }

    close(server_fd);
    close(client_fd);
}

// handle HTTPS CONNECT request
void handle_https_connect(int client_fd, char *request, size_t req_len) {
    char hostname[256], port_str[16];
    int port = 443;

    // parse CONNECT request
    char *space = strchr(request + 8, ' ');
    if (!space) {
        const char *err = "HTTP/1.1 400 Bad Request\r\n\r\n";
        send(client_fd, err, strlen(err), 0);
        close(client_fd);
        return;
    }

    size_t host_len = space - (request + 8);
    if (host_len >= sizeof(hostname)) {
        const char *err = "HTTP/1.1 400 Bad Request\r\n\r\n";
        send(client_fd, err, strlen(err), 0);
        close(client_fd);
        return;
    }

    strncpy(hostname, request + 8, host_len);
    hostname[host_len] = '\0';

    // extract hostname and port
    char *colon = strchr(hostname, ':');
    if (colon) {
        *colon = '\0';
        port = atoi(colon + 1);
    }

    // connect to upstream server
    int server_fd = connect_to_server(hostname, port);
    if (server_fd < 0) {
        const char *err = "HTTP/1.1 502 Bad Gateway\r\n\r\n";
        send(client_fd, err, strlen(err), 0);
        close(client_fd);
        return;
    }

    // send connection established to client
    const char *conn_est = "HTTP/1.1 200 Connection Established\r\n\r\n";
    if (send(client_fd, conn_est, strlen(conn_est), 0) <= 0) {
        close(server_fd);
        close(client_fd);
        return;
    }

    // generate fake certificate for this hostname
    X509 *cert = generate_cert(hostname);
    if (!cert) {
        close(server_fd);
        close(client_fd);
        return;
    }

    // create SSL contexts
    SSL_CTX *client_ctx = create_ssl_context_server();
    SSL_CTX *server_ctx = create_ssl_context_client();

    if (!client_ctx || !server_ctx) {
        if (client_ctx) SSL_CTX_free(client_ctx);
        if (server_ctx) SSL_CTX_free(server_ctx);
        X509_free(cert);
        close(server_fd);
        close(client_fd);
        return;
    }

    // set certificate and key for client SSL
    if (SSL_CTX_use_certificate(client_ctx, cert) <= 0 ||
        SSL_CTX_use_PrivateKey(client_ctx, ca_key) <= 0) {
        SSL_CTX_free(client_ctx);
        SSL_CTX_free(server_ctx);
        X509_free(cert);
        close(server_fd);
        close(client_fd);
        return;
    }

    // create SSL connections
    SSL *client_ssl = SSL_new(client_ctx);
    SSL_set_fd(client_ssl, client_fd);
    
    SSL *server_ssl = SSL_new(server_ctx);
    SSL_set_fd(server_ssl, server_fd);

    if (SSL_accept(client_ssl) <= 0) {
        SSL_free(client_ssl);
        SSL_CTX_free(client_ctx);
        SSL_free(server_ssl);
        SSL_CTX_free(server_ctx);
        X509_free(cert);
        close(server_fd);
        close(client_fd);
        return;
    }

    if (SSL_connect(server_ssl) <= 0) {
        SSL_free(client_ssl);
        SSL_CTX_free(client_ctx);
        SSL_free(server_ssl);
        SSL_CTX_free(server_ctx);
        X509_free(cert);
        close(server_fd);
        close(client_fd);
        return;
    }

    // read client's actual HTTPS request
    char *client_request = malloc(BUFFER_SIZE);
    if (!client_request) {
        SSL_free(client_ssl);
        SSL_CTX_free(client_ctx);
        SSL_free(server_ssl);
        SSL_CTX_free(server_ctx);
        X509_free(cert);
        close(server_fd);
        close(client_fd);
        return;
    }

    int request_bytes = SSL_read(client_ssl, client_request, BUFFER_SIZE - 1);
    if (request_bytes <= 0) {
        free(client_request);
        SSL_free(client_ssl);
        SSL_CTX_free(client_ctx);
        SSL_free(server_ssl);
        SSL_CTX_free(server_ctx);
        X509_free(cert);
        close(server_fd);
        close(client_fd);
        return;
    }
    client_request[request_bytes] = '\0';

    // Remove Accept-Encoding header to get uncompressed responses
    char *accept_encoding = strcasestr(client_request, "\r\nAccept-Encoding:");
    if (accept_encoding) {
        char *line_end = strstr(accept_encoding + 2, "\r\n");
        if (line_end) {
            memmove(accept_encoding, line_end, strlen(line_end) + 1);
            request_bytes = strlen(client_request);
        }
    }

    // forward request to server
    int sent = 0;
    while (sent < request_bytes) {
        int n = SSL_write(server_ssl, client_request + sent, request_bytes - sent);
        if (n <= 0) {
            free(client_request);
            SSL_free(client_ssl);
            SSL_CTX_free(client_ctx);
            SSL_free(server_ssl);
            SSL_CTX_free(server_ctx);
            X509_free(cert);
            close(server_fd);
            close(client_fd);
            return;
        }
        sent += n;
    }

    // collect full response from server
    char *full_response = malloc(MAX_RESPONSE_SIZE);
    if (!full_response) {
        free(client_request);
        SSL_free(client_ssl);
        SSL_CTX_free(client_ctx);
        SSL_free(server_ssl);
        SSL_CTX_free(server_ctx);
        X509_free(cert);
        close(server_fd);
        close(client_fd);
        return;
    }

    size_t total_received = 0;
    int bytes;
    while ((bytes = SSL_read(server_ssl, full_response + total_received,
                            MAX_RESPONSE_SIZE - total_received - 1)) > 0) {
        total_received += bytes;
        if (total_received >= MAX_RESPONSE_SIZE - 1) {
            break;
        }
        
        // check if we received complete response
        if (total_received > 4 && strstr(full_response, "\r\n\r\n")) {
            struct timeval tv = {0, 100000}; // 100ms
            select(0, NULL, NULL, NULL, &tv);
            
            int more = SSL_read(server_ssl, full_response + total_received,
                               MAX_RESPONSE_SIZE - total_received - 1);
            if (more > 0) {
                total_received += more;
            } else {
                break;
            }
        }
    }
    full_response[total_received] = '\0';

    // Try to enhance HTML via Flask (if LLM enabled)
    if (llm_enabled) {
        char *headers_end = strstr(full_response, "\r\n\r\n");
        if (headers_end && total_received > 100) {
            char *content_type = extract_content_type(full_response);
            int is_html = is_html_content_type(content_type);
            
            // check if compressed
            int is_compressed = 0;
            char *encoding = strcasestr(full_response, "Content-Encoding:");
            if (encoding) {
                if (strcasestr(encoding, "gzip") || strcasestr(encoding, "deflate")) {
                    is_compressed = 1;
                }
            }
            
            if (is_html && !is_compressed) {
                printf("[LLM] ü§ñ Ê£ÄÊµãÂà∞ HTMLÔºåÊ≠£Âú®Ë∞ÉÁî® Flask Ê≥®ÂÖ• JavaScript...\n");
                fflush(stdout);
                
                char *body = headers_end + 4;
                size_t body_len = total_received - (body - full_response);
                
                char full_url[2048];
                snprintf(full_url, sizeof(full_url), "https://%s", hostname);
                
                size_t enhanced_len = 0;
                char *enhanced_html = send_to_flask_enhance(body, full_url, &enhanced_len);
                
                if (enhanced_html && enhanced_len > 0 && enhanced_len < MAX_RESPONSE_SIZE) {
                    printf("[LLM] ‚úÖ Flask ËøîÂõûÂ¢ûÂº∫ HTML (%zu bytes)\n", enhanced_len);
                    fflush(stdout);
                    
                    // build new response with enhanced HTML
                    char *status_end = strstr(full_response, "\r\n");
                    if (status_end) {
                        size_t status_len = status_end - full_response;
                        char *new_response = malloc(MAX_RESPONSE_SIZE);
                        if (new_response) {
                            memcpy(new_response, full_response, status_len);
                            int resp_len = status_len;
                            resp_len += snprintf(new_response + resp_len, MAX_RESPONSE_SIZE - resp_len,
                                "\r\nX-Proxy:CS112\r\n"
                                "Content-Length: %zu\r\n"
                                "Content-Type: text/html; charset=utf-8\r\n"
                                "Connection: close\r\n"
                                "\r\n", enhanced_len);
                            
                            memcpy(new_response + resp_len, enhanced_html, enhanced_len);
                            resp_len += enhanced_len;
                            
                            // send enhanced response to client
                            sent = 0;
                            while (sent < resp_len) {
                                int n = SSL_write(client_ssl, new_response + sent, resp_len - sent);
                                if (n <= 0) break;
                                sent += n;
                            }
                            
                            free(new_response);
                            free(enhanced_html);
                            free(client_request);
                            free(full_response);
                            if (content_type) free(content_type);
                            
                            SSL_free(client_ssl);
                            SSL_CTX_free(client_ctx);
                            SSL_free(server_ssl);
                            SSL_CTX_free(server_ctx);
                            X509_free(cert);
                            close(server_fd);
                            close(client_fd);
                            return;
                        }
                    }
                    free(enhanced_html);
                }
            }
            if (content_type) free(content_type);
        }
    }

    // fallback: inject X-Proxy header and send original response
    size_t resp_len = total_received;
    if (total_received >= 5 && strncmp(full_response, "HTTP/", 5) == 0) {
        inject_header(full_response, &resp_len, MAX_RESPONSE_SIZE);
    }

    sent = 0;
    while (sent < (int)resp_len) {
        int n = SSL_write(client_ssl, full_response + sent, resp_len - sent);
        if (n <= 0) break;
        sent += n;
    }

    free(client_request);
    free(full_response);

    SSL_free(client_ssl);
    SSL_CTX_free(client_ctx);
    SSL_free(server_ssl);
    SSL_CTX_free(server_ctx);
    X509_free(cert);
    close(server_fd);
    close(client_fd);
}

// connect to upstream server
int connect_to_server(const char *hostname, int port) {
    struct hostent *host = gethostbyname(hostname);
    if (!host) {
        return -1;
    }

    int sockfd = socket(AF_INET, SOCK_STREAM, 0);
    if (sockfd < 0) {
        return -1;
    }

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(port);
    memcpy(&server_addr.sin_addr, host->h_addr_list[0], host->h_length);

    if (connect(sockfd, (struct sockaddr *)&server_addr, sizeof(server_addr)) < 0) {
        close(sockfd);
        return -1;
    }

    return sockfd;
}

// generate fake certificate for hostname
X509 *generate_cert(const char *hostname) {
    X509 *cert = X509_new();
    if (!cert) {
        fprintf(stderr, "Failed to create X509 certificate\n");
        return NULL;
    }

    if (!X509_set_version(cert, 2)) {
        fprintf(stderr, "Failed to set certificate version\n");
        X509_free(cert);
        return NULL;
    }

    // set serial number based on time and hostname
    unsigned long serial = (unsigned long)time(NULL);
    for (size_t i = 0; hostname[i] != '\0'; i++) {
        serial = serial * 31 + hostname[i];
    }
    ASN1_INTEGER_set(X509_get_serialNumber(cert), serial);

    // set validity: start 1 day in past to handle clock skew, valid for 1 year
    X509_gmtime_adj(X509_get_notBefore(cert), -86400L);
    X509_gmtime_adj(X509_get_notAfter(cert), 31536000L);

    // set certificate subject
    X509_NAME *name = X509_get_subject_name(cert);
    X509_NAME_add_entry_by_txt(name, "C", MBSTRING_ASC, 
                               (unsigned char *)"US", -1, -1, 0);
    X509_NAME_add_entry_by_txt(name, "O", MBSTRING_ASC, 
                               (unsigned char *)"CS112 Proxy", -1, -1, 0);
    X509_NAME_add_entry_by_txt(name, "CN", MBSTRING_ASC, 
                               (unsigned char *)hostname, -1, -1, 0);

    X509_set_issuer_name(cert, X509_get_subject_name(ca_cert));

    // set public key
    if (!X509_set_pubkey(cert, ca_key)) {
        fprintf(stderr, "Failed to set public key\n");
        X509_free(cert);
        return NULL;
    }

    // add X.509 v3 extensions
    X509V3_CTX ctx;
    X509V3_set_ctx_nodb(&ctx);
    X509V3_set_ctx(&ctx, ca_cert, cert, NULL, NULL, 0);
    
    X509_EXTENSION *ext = X509V3_EXT_conf_nid(NULL, &ctx, 
                                              NID_basic_constraints, 
                                              "CA:FALSE");
    if (ext) {
        X509_add_ext(cert, ext, -1);
        X509_EXTENSION_free(ext);
    }

    ext = X509V3_EXT_conf_nid(NULL, &ctx, NID_key_usage, 
                              "digitalSignature,keyEncipherment");
    if (ext) {
        X509_add_ext(cert, ext, -1);
        X509_EXTENSION_free(ext);
    }

    ext = X509V3_EXT_conf_nid(NULL, &ctx, NID_ext_key_usage, 
                              "serverAuth");
    if (ext) {
        X509_add_ext(cert, ext, -1);
        X509_EXTENSION_free(ext);
    }

    // add SAN extension, critical for modern browsers
    char san[512];
    snprintf(san, sizeof(san), "DNS:%s", hostname);
    ext = X509V3_EXT_conf_nid(NULL, &ctx, NID_subject_alt_name, san);
    if (ext) {
        X509_add_ext(cert, ext, -1);
        X509_EXTENSION_free(ext);
    } else {
        fprintf(stderr, "Warning: Failed to add SAN extension for %s\n", hostname);
    }

    // sign the certificate with CA key
    if (!X509_sign(cert, ca_key, EVP_sha256())) {
        fprintf(stderr, "Failed to sign certificate\n");
        ERR_print_errors_fp(stderr);
        X509_free(cert);
        return NULL;
    }

    return cert;
}

// create SSL context for server side (to client)
SSL_CTX *create_ssl_context_server(void) {
    SSL_CTX *ctx = SSL_CTX_new(SSLv23_server_method());
    if (!ctx) {
        return NULL;
    }
    return ctx;
}

// create SSL context for client side (to upstream server)
SSL_CTX *create_ssl_context_client(void) {
    SSL_CTX *ctx = SSL_CTX_new(SSLv23_client_method());
    if (!ctx) {
        return NULL;
    }
    SSL_CTX_set_options(ctx, SSL_OP_NO_SSLv2 | SSL_OP_NO_SSLv3);
    return ctx;
}

// inject X-Proxy:CS112 header
void inject_header(char *response, size_t *response_len, size_t buffer_size) {
    char *header_end = strstr(response, "\r\n\r\n");
    if (!header_end) {
        return;
    }

    const char *new_header = "X-Proxy:CS112\r\n";
    size_t header_len = strlen(new_header);

    if (*response_len + header_len >= buffer_size) {
        return;
    }

    memmove(header_end + header_len, header_end, 
           *response_len - (header_end - response));
    memcpy(header_end, new_header, header_len);
    *response_len += header_len;
}

// Send HTML to Flask for enhancement (inject JavaScript)
char *send_to_flask_enhance(const char *html, const char *url, size_t *out_len) {
    time_t now = time(NULL);
    if (!flask_available && (now - last_flask_check) < 60) {
        return NULL;
    }
    
    int sockfd = socket(AF_INET, SOCK_STREAM, 0);
    if (sockfd < 0) {
        return NULL;
    }
    
    struct sockaddr_in flask_addr;
    memset(&flask_addr, 0, sizeof(flask_addr));
    flask_addr.sin_family = AF_INET;
    flask_addr.sin_port = htons(FLASK_PORT);
    inet_pton(AF_INET, FLASK_HOST, &flask_addr.sin_addr);
    
    struct timeval timeout;
    timeout.tv_sec = 1;
    timeout.tv_usec = 0;
    setsockopt(sockfd, SOL_SOCKET, SO_RCVTIMEO, &timeout, sizeof(timeout));
    setsockopt(sockfd, SOL_SOCKET, SO_SNDTIMEO, &timeout, sizeof(timeout));
    
    if (connect(sockfd, (struct sockaddr *)&flask_addr, sizeof(flask_addr)) < 0) {
        close(sockfd);
        flask_available = 0;
        last_flask_check = now;
        printf("[LLM] ‚ö†Ô∏è  Flask ÊúçÂä°Âô®‰∏çÂèØÁî®\n");
        fflush(stdout);
        return NULL;
    }
    
    flask_available = 1;
    
    // encode HTML as base64
    size_t html_len = strlen(html);
    size_t url_len = url ? strlen(url) : 0;
    
    size_t b64_buf_len = ((html_len + 2) / 3) * 4 + 1;
    char *html_b64 = malloc(b64_buf_len);
    if (!html_b64) {
        close(sockfd);
        return NULL;
    }
    
    int encoded_len = EVP_EncodeBlock((unsigned char*)html_b64,
                                      (unsigned char*)html,
                                      html_len);
    html_b64[encoded_len] = '\0';
    
    // build JSON
    char *json_body = malloc(encoded_len + url_len + 1024);
    if (!json_body) {
        free(html_b64);
        close(sockfd);
        return NULL;
    }
    
    strcpy(json_body, "{\"html_base64\":\"");
    strcat(json_body, html_b64);
    strcat(json_body, "\",\"url\":\"");
    if (url) {
        strcat(json_body, url);
    }
    strcat(json_body, "\"}");
    
    free(html_b64);
    size_t json_len = strlen(json_body);
    
    // build HTTP request
    char http_request[2048];
    snprintf(http_request, sizeof(http_request),
             "POST /enhance HTTP/1.1\r\n"
             "Host: %s:%d\r\n"
             "Content-Type: application/json\r\n"
             "Content-Length: %zu\r\n"
             "Connection: close\r\n"
             "\r\n",
             FLASK_HOST, FLASK_PORT, json_len);
    
    // send request
    send(sockfd, http_request, strlen(http_request), 0);
    send(sockfd, json_body, json_len, 0);
    free(json_body);
    
    // receive response
    char *response = malloc(MAX_RESPONSE_SIZE);
    if (!response) {
        close(sockfd);
        return NULL;
    }
    
    size_t total_received = 0;
    ssize_t bytes;
    while ((bytes = recv(sockfd, response + total_received, 
                        MAX_RESPONSE_SIZE - total_received - 1, 0)) > 0) {
        total_received += bytes;
        if (total_received >= MAX_RESPONSE_SIZE - 1) {
            break;
        }
    }
    response[total_received] = '\0';
    close(sockfd);
    
    // parse JSON response
    char *json_start = strstr(response, "\r\n\r\n");
    if (!json_start) {
        free(response);
        return NULL;
    }
    json_start += 4;
    
    // find html_base64 field
    char *b64_field = strstr(json_start, "\"html_base64\":");
    if (!b64_field) {
        free(response);
        return NULL;
    }
    b64_field += 14;
    while (*b64_field == ' ') b64_field++;
    
    if (*b64_field != '"') {
        free(response);
        return NULL;
    }
    b64_field++;
    
    // find end of base64 string
    char *b64_end = b64_field;
    while (*b64_end != '\0' && *b64_end != '"') {
        b64_end++;
    }
    
    size_t b64_len = b64_end - b64_field;
    
    // decode base64
    char *decoded = malloc(b64_len);
    if (!decoded) {
        free(response);
        return NULL;
    }
    
    int decoded_len = EVP_DecodeBlock((unsigned char*)decoded, 
                                      (unsigned char*)b64_field, 
                                      b64_len);
    
    if (decoded_len < 0) {
        free(decoded);
        free(response);
        return NULL;
    }
    
    // calculate actual length (remove padding)
    int padding = 0;
    if (b64_len > 0 && b64_field[b64_len - 1] == '=') padding++;
    if (b64_len > 1 && b64_field[b64_len - 2] == '=') padding++;
    
    decoded_len -= padding;
    
    if (decoded_len >= 0) {
        decoded[decoded_len] = '\0';
    } else {
        decoded_len = 0;
        decoded[0] = '\0';
    }
    
    *out_len = decoded_len;
    free(response);
    
    return decoded;
}

// check if content type is HTML
int is_html_content_type(const char *content_type) {
    if (!content_type) return 0;
    return (strstr(content_type, "text/html") != NULL);
}

// extract content-type from headers
char *extract_content_type(const char *headers) {
    char *ct = strcasestr(headers, "Content-Type:");
    if (!ct) {
        return NULL;
    }
    
    ct += 13; // skip "Content-Type:"
    while (*ct == ' ') ct++;
    
    char *end = strstr(ct, "\r\n");
    if (!end) {
        return NULL;
    }
    
    size_t len = end - ct;
    char *result = malloc(len + 1);
    if (!result) {
        return NULL;
    }
    
    memcpy(result, ct, len);
    result[len] = '\0';
    
    return result;
}
