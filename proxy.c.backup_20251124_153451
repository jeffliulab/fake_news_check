// CS112 Final Project Part 1 - HTTPS MITM Proxy

#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>
#include <pthread.h>
#include <signal.h>
#include <errno.h>
#include <sys/select.h>
#include <fcntl.h>
#include <time.h>
#include <sys/stat.h>
#include <sys/types.h>
// openssl libraries, necessary for SSL/TLS and certificate operations
#include <openssl/ssl.h>
#include <openssl/err.h>
#include <openssl/x509.h>
#include <openssl/x509v3.h>
#include <openssl/pem.h>
#include <openssl/rsa.h>
#include <openssl/evp.h>
// zlib for gzip decompression
#include <zlib.h>

#define BUFFER_SIZE 65536
#define MAX_HEADER_SIZE 8192
#define BACKLOG 128

// global CA certificate and key for signing fake certificates
static X509 *ca_cert = NULL;
static EVP_PKEY *ca_key = NULL;

// global flag to enable/disable LLM functionality
static int llm_enabled = 0;

// client connection context
typedef struct {
    int client_fd;
    struct sockaddr_in client_addr;
} client_context_t;

// function prototypes
void *handle_client(void *arg);
void handle_http_request(int client_fd, char *request, size_t req_len);
void handle_https_connect(int client_fd, char *request, size_t req_len);
int connect_to_server(const char *hostname, int port);
X509 *generate_cert(const char *hostname);
SSL_CTX *create_ssl_context_server(void);
SSL_CTX *create_ssl_context_client(void);
void inject_header(char *response, size_t *response_len, size_t buffer_size);
int read_line(int fd, char *buf, size_t max_len);
void parse_host_port(char *host_header, char **hostname, int *port);
int load_ca_cert_and_key(const char *cert_path, const char *key_path);
int send_to_fake_news_service(const char *html_content, size_t content_len, char *result_buf, size_t result_buf_size);
void save_html_to_file(const char *html_content, size_t content_len);
char* decompress_gzip(const char *compressed_data, size_t compressed_len, size_t *decompressed_len);
char* compress_gzip(const char *data, size_t data_len, size_t *compressed_len);
void save_html_with_decompression(const char *raw_content, size_t content_len);

// signal handler to prevent crashes when connection breaks
void signal_handler(int sig) {
    if (sig == SIGPIPE) {
        return;
    }
}

int main(int argc, char *argv[]) {
    if (argc < 4 || argc > 5) {
        fprintf(stderr, "Usage: %s <port> <ca_cert_path> <ca_key_path> [llm=true]\n", argv[0]);
        fprintf(stderr, "  Optional: llm=true to enable LLM functionality\n");
        exit(EXIT_FAILURE);
    }

    int port = atoi(argv[1]);
    const char *ca_cert_path = argv[2];
    const char *ca_key_path = argv[3];
    
    // parse optional llm parameter
    if (argc == 5) {
        if (strcmp(argv[4], "llm=true") == 0) {
            llm_enabled = 1;
            printf("âœ… LLM åŠŸèƒ½å·²å¯ç”¨\n");
        } else if (strcmp(argv[4], "llm=false") == 0) {
            llm_enabled = 0;
            printf("â­ï¸  LLM åŠŸèƒ½å·²ç¦ç”¨\n");
        } else {
            fprintf(stderr, "Warning: Unknown parameter '%s', LLM disabled\n", argv[4]);
            llm_enabled = 0;
        }
    } else {
        llm_enabled = 0;
        printf("â­ï¸  LLM åŠŸèƒ½æœªå¯ç”¨ (é»˜è®¤)\n");
    }

    // load CA certificate and key
    if (load_ca_cert_and_key(ca_cert_path, ca_key_path) != 0) {
        fprintf(stderr, "Failed to load CA certificate and key\n");
        exit(EXIT_FAILURE);
    }

    // initialize OpenSSL
    SSL_library_init();
    SSL_load_error_strings();
    OpenSSL_add_all_algorithms();

    signal(SIGPIPE, signal_handler);

    // create listening socket
    int listen_fd = socket(AF_INET, SOCK_STREAM, 0);
    if (listen_fd < 0) {
        perror("socket");
        exit(EXIT_FAILURE);
    }

    int opt = 1;
    if (setsockopt(listen_fd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt)) < 0) {
        perror("setsockopt");
        close(listen_fd);
        exit(EXIT_FAILURE);
    }

    // bind socket
    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = INADDR_ANY;
    server_addr.sin_port = htons(port);

    if (bind(listen_fd, (struct sockaddr *)&server_addr, sizeof(server_addr)) < 0) {
        perror("bind");
        close(listen_fd);
        exit(EXIT_FAILURE);
    }

    if (listen(listen_fd, BACKLOG) < 0) {
        perror("listen");
        close(listen_fd);
        exit(EXIT_FAILURE);
    }

    printf("Proxy server listening on port %d\n", port);

    // main loop: accept and handle client connections
    while (1) {
        struct sockaddr_in client_addr;
        socklen_t client_len = sizeof(client_addr);
        int client_fd = accept(listen_fd, (struct sockaddr *)&client_addr, &client_len);

        if (client_fd < 0) {
            perror("accept");
            continue;
        }

        client_context_t *ctx = malloc(sizeof(client_context_t));
        if (!ctx) {
            close(client_fd);
            continue;
        }
        ctx->client_fd = client_fd;
        ctx->client_addr = client_addr;

        // handle each client in a separate thread
        pthread_t thread;
        pthread_attr_t attr;
        pthread_attr_init(&attr);
        pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
        
        if (pthread_create(&thread, &attr, handle_client, ctx) != 0) {
            perror("pthread_create");
            close(client_fd);
            free(ctx);
        }
        pthread_attr_destroy(&attr);
    }

    close(listen_fd);
    X509_free(ca_cert);
    EVP_PKEY_free(ca_key);
    return 0;
}

// load CA certificate and key from files
int load_ca_cert_and_key(const char *cert_path, const char *key_path) {
    FILE *fp = fopen(cert_path, "r");
    if (!fp) {
        perror("fopen ca_cert");
        return -1;
    }
    ca_cert = PEM_read_X509(fp, NULL, NULL, NULL);
    fclose(fp);
    if (!ca_cert) {
        fprintf(stderr, "Failed to read CA certificate\n");
        return -1;
    }

    fp = fopen(key_path, "r");
    if (!fp) {
        perror("fopen ca_key");
        X509_free(ca_cert);
        ca_cert = NULL;
        return -1;
    }
    ca_key = PEM_read_PrivateKey(fp, NULL, NULL, NULL);
    fclose(fp);
    if (!ca_key) {
        fprintf(stderr, "Failed to read CA key\n");
        X509_free(ca_cert);
        ca_cert = NULL;
        return -1;
    }

    return 0;
}

// handle client connection in separate thread
void *handle_client(void *arg) {
    client_context_t *ctx = (client_context_t *)arg;
    int client_fd = ctx->client_fd;
    free(ctx);

    struct timeval tv;
    tv.tv_sec = 30;
    tv.tv_usec = 0;
    setsockopt(client_fd, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv));
    setsockopt(client_fd, SOL_SOCKET, SO_SNDTIMEO, &tv, sizeof(tv));

    char request[MAX_HEADER_SIZE];
    ssize_t bytes_read = recv(client_fd, request, sizeof(request) - 1, 0);

    if (bytes_read <= 0) {
        close(client_fd);
        return NULL;
    }

    request[bytes_read] = '\0';

    // check if CONNECT request for HTTPS, otherwise handle as HTTP
    if (strncmp(request, "CONNECT ", 8) == 0) {
        handle_https_connect(client_fd, request, bytes_read);
    } else if (strncmp(request, "GET ", 4) == 0 || 
               strncmp(request, "POST ", 5) == 0 ||
               strncmp(request, "HEAD ", 5) == 0) {
        handle_http_request(client_fd, request, bytes_read);
    } else {
        const char *err = "HTTP/1.1 501 Not Implemented\r\n\r\n";
        send(client_fd, err, strlen(err), 0);
    }

    close(client_fd);
    return NULL;
}

// handle plain HTTP requests
void handle_http_request(int client_fd, char *request, size_t req_len) {
    char method[16], url[2048], version[16];
    char hostname[256] = {0};
    int port = 80;
    char *host_line = NULL;

    if (sscanf(request, "%15s %2047s %15s", method, url, version) != 3) {
        const char *err = "HTTP/1.1 400 Bad Request\r\n\r\n";
        send(client_fd, err, strlen(err), 0);
        return;
    }

    // extract hostname from Host header
    host_line = strstr(request, "Host: ");
    if (host_line) {
        host_line += 6;
        char *end = strstr(host_line, "\r\n");
        if (end) {
            size_t len = end - host_line;
            if (len < sizeof(hostname)) {
                strncpy(hostname, host_line, len);
                hostname[len] = '\0';
                parse_host_port(hostname, NULL, &port);
            }
        }
    }

    if (hostname[0] == '\0') {
        const char *err = "HTTP/1.1 400 Bad Request\r\n\r\n";
        send(client_fd, err, strlen(err), 0);
        return;
    }

    // connect to the target server
    int server_fd = connect_to_server(hostname, port);
    if (server_fd < 0) {
        const char *err = "HTTP/1.1 502 Bad Gateway\r\n\r\n";
        send(client_fd, err, strlen(err), 0);
        return;
    }

    // forward request to server
    ssize_t sent = 0;
    while (sent < (ssize_t)req_len) {
        ssize_t n = send(server_fd, request + sent, req_len - sent, 0);
        if (n < 0) {
            close(server_fd);
            return;
        }
        sent += n;
    }

    // receive response and inject X-Proxy header
    char response[BUFFER_SIZE];
    ssize_t total_bytes = 0;
    int first_chunk = 1;
    
    while (1) {
        ssize_t bytes = recv(server_fd, response, sizeof(response), 0);
        if (bytes <= 0) {
            break;
        }
        
        size_t response_len = bytes;
        
        // inject X-Proxy header in first chunk
        if (first_chunk && bytes >= 5 && strncmp(response, "HTTP/", 5) == 0) {
            inject_header(response, &response_len, sizeof(response));
            first_chunk = 0;
        }
        
        ssize_t sent_to_client = 0;
        while (sent_to_client < (ssize_t)response_len) {
            ssize_t n = send(client_fd, response + sent_to_client, 
                           response_len - sent_to_client, 0);
            if (n < 0) {
                close(server_fd);
                return;
            }
            sent_to_client += n;
        }
        
        total_bytes += bytes;
    }

    close(server_fd);
}

// handle HTTPS CONNECT requests with TLS interception
void handle_https_connect(int client_fd, char *request, size_t req_len) {
    char hostname[256], port_str[16];
    int port = 443;

    // parse CONNECT request: CONNECT hostname:port HTTP/1.1
    char *space = strchr(request + 8, ' ');
    if (!space) {
        const char *err = "HTTP/1.1 400 Bad Request\r\n\r\n";
        send(client_fd, err, strlen(err), 0);
        return;
    }

    size_t host_len = space - (request + 8);
    if (host_len >= sizeof(hostname)) {
        const char *err = "HTTP/1.1 400 Bad Request\r\n\r\n";
        send(client_fd, err, strlen(err), 0);
        return;
    }

    strncpy(hostname, request + 8, host_len);
    hostname[host_len] = '\0';

    char *colon = strchr(hostname, ':');
    if (colon) {
        *colon = '\0';
        port = atoi(colon + 1);
    }

    // connect to the upstream HTTPS server
    int server_fd = connect_to_server(hostname, port);
    if (server_fd < 0) {
        const char *err = "HTTP/1.1 502 Bad Gateway\r\n\r\n";
        send(client_fd, err, strlen(err), 0);
        return;
    }

    // create SSL connection to upstream server (proxy acts as client)
    SSL_CTX *server_ctx = create_ssl_context_client();
    if (!server_ctx) {
        fprintf(stderr, "Failed to create server SSL context\n");
        close(server_fd);
        const char *err = "HTTP/1.1 502 Bad Gateway\r\n\r\n";
        send(client_fd, err, strlen(err), 0);
        return;
    }

    SSL *server_ssl = SSL_new(server_ctx);
    if (!server_ssl) {
        fprintf(stderr, "Failed to create server SSL object\n");
        SSL_CTX_free(server_ctx);
        close(server_fd);
        const char *err = "HTTP/1.1 502 Bad Gateway\r\n\r\n";
        send(client_fd, err, strlen(err), 0);
        return;
    }

    SSL_set_fd(server_ssl, server_fd);
    SSL_set_tlsext_host_name(server_ssl, hostname);

    int ssl_ret = SSL_connect(server_ssl);
    if (ssl_ret <= 0) {
        SSL_free(server_ssl);
        SSL_CTX_free(server_ctx);
        close(server_fd);
        const char *err = "HTTP/1.1 502 Bad Gateway\r\n\r\n";
        send(client_fd, err, strlen(err), 0);
        return;
    }

    // send 200 Connection Established to client
    const char *response = "HTTP/1.1 200 Connection Established\r\n\r\n";
    send(client_fd, response, strlen(response), 0);

    // create SSL context for client connection (proxy acts as server)
    SSL_CTX *client_ctx = create_ssl_context_server();
    if (!client_ctx) {
        SSL_shutdown(server_ssl);
        SSL_free(server_ssl);
        SSL_CTX_free(server_ctx);
        close(server_fd);
        return;
    }

    // generate fake certificate for this hostname
    X509 *cert = generate_cert(hostname);
    if (!cert) {
        SSL_CTX_free(client_ctx);
        SSL_shutdown(server_ssl);
        SSL_free(server_ssl);
        SSL_CTX_free(server_ctx);
        close(server_fd);
        return;
    }

    SSL_CTX_use_certificate(client_ctx, cert);
    SSL_CTX_use_PrivateKey(client_ctx, ca_key);

    SSL *client_ssl = SSL_new(client_ctx);
    if (!client_ssl) {
        fprintf(stderr, "Failed to create client SSL object\n");
        SSL_CTX_free(client_ctx);
        X509_free(cert);
        SSL_shutdown(server_ssl);
        SSL_free(server_ssl);
        SSL_CTX_free(server_ctx);
        close(server_fd);
        return;
    }

    SSL_set_fd(client_ssl, client_fd);

    int accept_ret = SSL_accept(client_ssl);
    if (accept_ret <= 0) {
        SSL_free(client_ssl);
        SSL_CTX_free(client_ctx);
        X509_free(cert);
        SSL_shutdown(server_ssl);
        SSL_free(server_ssl);
        SSL_CTX_free(server_ctx);
        close(server_fd);
        return;
    }

    // relay encrypted data between client and server with header injection
    fd_set readfds;
    int max_fd = (client_fd > server_fd) ? client_fd : server_fd;
    char client_buffer[BUFFER_SIZE];
    char server_buffer[BUFFER_SIZE];
    int active = 1;
    int first_response = 1;
    int llm_processed = 0;  // æ ‡è®°æ˜¯å¦å·²ç»è°ƒç”¨è¿‡ LLM

    int flags = fcntl(client_fd, F_GETFL, 0);
    fcntl(client_fd, F_SETFL, flags | O_NONBLOCK);
    flags = fcntl(server_fd, F_GETFL, 0);
    fcntl(server_fd, F_SETFL, flags | O_NONBLOCK);

    while (active) {
        FD_ZERO(&readfds);
        FD_SET(client_fd, &readfds);
        FD_SET(server_fd, &readfds);

        struct timeval timeout;
        timeout.tv_sec = 60;
        timeout.tv_usec = 0;

        int ret = select(max_fd + 1, &readfds, NULL, NULL, &timeout);
        if (ret < 0) {
            if (errno == EINTR) continue;
            break;
        }
        if (ret == 0) {
            break;
        }

        // relay data from client to server
        if (FD_ISSET(client_fd, &readfds)) {
            int bytes = SSL_read(client_ssl, client_buffer, sizeof(client_buffer));
            if (bytes <= 0) {
                int err = SSL_get_error(client_ssl, bytes);
                if (err != SSL_ERROR_WANT_READ && err != SSL_ERROR_WANT_WRITE) {
                    break;
                }
            } else {
                int sent = 0;
                while (sent < bytes) {
                    int n = SSL_write(server_ssl, client_buffer + sent, bytes - sent);
                    if (n <= 0) {
                        int err = SSL_get_error(server_ssl, n);
                        if (err != SSL_ERROR_WANT_READ && err != SSL_ERROR_WANT_WRITE) {
                            active = 0;
                            break;
                        }
                    } else {
                        sent += n;
                    }
                }
            }
        }

        // // relay data from server to client and inject header
        // if (FD_ISSET(server_fd, &readfds) && active) {
        //     int bytes = SSL_read(server_ssl, server_buffer, sizeof(server_buffer));
        //     if (bytes <= 0) {
        //         int err = SSL_get_error(server_ssl, bytes);
        //         if (err != SSL_ERROR_WANT_READ && err != SSL_ERROR_WANT_WRITE) {
        //             break;
        //         }
        //     } else {
        //         size_t len = bytes;
        //         if (first_response && bytes >= 5 && strncmp(server_buffer, "HTTP/", 5) == 0) {
        //             inject_header(server_buffer, &len, sizeof(server_buffer));
        //             first_response = 0;
        //         }
                
        //         int sent = 0;
        //         while (sent < (int)len) {
        //             int n = SSL_write(client_ssl, server_buffer + sent, len - sent);
        //             if (n <= 0) {
        //                 int err = SSL_get_error(client_ssl, n);
        //                 if (err != SSL_ERROR_WANT_READ && err != SSL_ERROR_WANT_WRITE) {
        //                     active = 0;
        //                     break;
        //                 }
        //             } else {
        //                 sent += n;
        //             }
        //         }
        //     }
        // }
        // relay data from server to client and inject header
        // HACKATHONä¿®æ”¹ç‰ˆï¼ˆè½¬å‘LLMï¼‰
        if (FD_ISSET(server_fd, &readfds) && active) {
            // 1. è¯»å–æœåŠ¡å™¨æ•°æ®ï¼Œé¢„ç•™ 1 å­—èŠ‚ç»™ null ç»“å°¾
            int bytes = SSL_read(server_ssl, server_buffer, sizeof(server_buffer) - 1);
            
            if (bytes <= 0) {
                int err = SSL_get_error(server_ssl, bytes);
                if (err != SSL_ERROR_WANT_READ && err != SSL_ERROR_WANT_WRITE) {
                    break; // çœŸæ­£çš„é”™è¯¯ï¼Œæ–­å¼€è¿æ¥
                }
            } else {
                // ç¡®ä¿ buffer æ˜¯åˆæ³•çš„ C å­—ç¬¦ä¸²
                server_buffer[bytes] = '\0';
                size_t len = bytes; // ä½¿ç”¨ len æ¥è·Ÿè¸ªå®é™…æ•°æ®é•¿åº¦

                // ================== GZIP + LLM ä¿®æ”¹éƒ¨åˆ†å¼€å§‹ ==================
                
                // LLM å¤„ç†é€»è¾‘ï¼šæ‹¦æˆª gzip å‹ç¼©çš„ HTMLï¼Œè§£å‹ï¼Œæ€»ç»“ï¼Œæ’å…¥ï¼Œé‡æ–°å‹ç¼©
                if (llm_enabled && !llm_processed && first_response && len >= 5 && strncmp(server_buffer, "HTTP/", 5) == 0) {
                    // æ£€æŸ¥ Content-Type æ˜¯å¦ä¸º HTML
                    int is_html = 0;
                    int is_gzip = 0;
                    
                    char *content_type = strstr(server_buffer, "Content-Type:");
                    if (!content_type) {
                        content_type = strstr(server_buffer, "content-type:");
                    }
                    
                    if (content_type) {
                        char *line_end = strstr(content_type, "\r\n");
                        if (line_end) {
                            char content_type_line[256] = {0};
                            size_t line_len = line_end - content_type;
                            if (line_len < sizeof(content_type_line)) {
                                strncpy(content_type_line, content_type, line_len);
                                if (strstr(content_type_line, "text/html") != NULL) {
                                    is_html = 1;
                                }
                            }
                        }
                    }
                    
                    // æ£€æŸ¥ Content-Encoding æ˜¯å¦ä¸º gzip
                    char *content_encoding = strstr(server_buffer, "Content-Encoding:");
                    if (!content_encoding) {
                        content_encoding = strstr(server_buffer, "content-encoding:");
                    }
                    
                    if (content_encoding) {
                        char *line_end = strstr(content_encoding, "\r\n");
                        if (line_end) {
                            char encoding_line[256] = {0};
                            size_t line_len = line_end - content_encoding;
                            if (line_len < sizeof(encoding_line)) {
                                strncpy(encoding_line, content_encoding, line_len);
                                if (strstr(encoding_line, "gzip") != NULL) {
                                    is_gzip = 1;
                                }
                            }
                        }
                    }
                    
                    // åªæœ‰åŒæ—¶æ»¡è¶³ HTML + gzip æ‰å¤„ç†
                    if (is_html && is_gzip) {
                        printf("\n========================================\n");
                        printf("[Proxy] ğŸ¯ æ‹¦æˆªåˆ° gzip å‹ç¼©çš„ HTML å“åº”\n");
                        printf("[Proxy] åŸå§‹å†…å®¹é•¿åº¦: %zu å­—èŠ‚\n", len);
                        
                        // åˆ†ç¦» header å’Œ body
                        char *header_end = strstr(server_buffer, "\r\n\r\n");
                        if (header_end) {
                            size_t header_len = (header_end - server_buffer) + 4; // åŒ…æ‹¬ \r\n\r\n
                            const char *body_start = server_buffer + header_len;
                            size_t body_len = len - header_len;
                            
                            printf("[Proxy] HTTP Header é•¿åº¦: %zu å­—èŠ‚\n", header_len);
                            printf("[Proxy] gzip Body é•¿åº¦: %zu å­—èŠ‚\n", body_len);
                            
                            // è§£å‹ gzip
                            size_t decompressed_len = 0;
                            char *decompressed = decompress_gzip(body_start, body_len, &decompressed_len);
                            
                            if (decompressed && decompressed_len > 0) {
                                printf("[Proxy] âœ… gzip è§£å‹æˆåŠŸï¼Œè§£å‹åé•¿åº¦: %zu å­—èŠ‚\n", decompressed_len);
                                
                                // å‘é€ç»™ LLM è·å–æ€»ç»“
                                printf("[Proxy] ğŸ¤– æ­£åœ¨è°ƒç”¨ LLM è¿›è¡Œå†…å®¹æ€»ç»“...\n");
                                char summary[4096] = {0};
                                int ret = send_to_fake_news_service(decompressed, decompressed_len, summary, sizeof(summary));
                                
                                if (ret == 0 && summary[0] != '\0' && strstr(summary, "__LLM_FAILED__") == NULL) {
                                    printf("[Proxy] âœ… LLM æ€»ç»“æˆåŠŸ\n");
                                    printf("[Proxy] ğŸ“ æ€»ç»“å†…å®¹: %s\n", summary);
                                    
                                    // åœ¨ HTML å¼€å¤´æ’å…¥æ€»ç»“ï¼ˆåœ¨ <body> åé¢æˆ– HTML å¼€å¤´ï¼‰
                                    char *modified_html = malloc(decompressed_len + 10240); // é¢„ç•™è¶³å¤Ÿç©ºé—´
                                    if (modified_html) {
                                        // æ„é€ ä¸€ä¸ªé†’ç›®çš„æ€»ç»“æ¡†
                                        char summary_box[8192];
                                        snprintf(summary_box, sizeof(summary_box),
                                            "<div style='position:fixed;top:10px;right:10px;width:300px;background:#fff3cd;border:2px solid #ffc107;padding:15px;border-radius:8px;box-shadow:0 4px 6px rgba(0,0,0,0.1);z-index:999999;font-family:Arial,sans-serif;'>"
                                            "<h3 style='margin:0 0 10px 0;color:#856404;font-size:16px;'>ğŸ¤– AI å†…å®¹æ€»ç»“</h3>"
                                            "<p style='margin:0;color:#856404;font-size:14px;line-height:1.5;'>%s</p>"
                                            "</div>",
                                            summary);
                                        
                                        // å°è¯•åœ¨ <body> åæ’å…¥
                                        char *body_tag = strstr(decompressed, "<body");
                                        if (!body_tag) {
                                            body_tag = strstr(decompressed, "<BODY");
                                        }
                                        if (body_tag) {
                                            // æ‰¾åˆ° <body...> ç»“æŸçš„ >
                                            char *body_end = strchr(body_tag, '>');
                                            if (body_end) {
                                                body_end++; // æŒ‡å‘ > åé¢
                                                size_t before_len = body_end - decompressed;
                                                
                                                // å¤åˆ¶ <body> ä¹‹å‰çš„å†…å®¹
                                                memcpy(modified_html, decompressed, before_len);
                                                // æ’å…¥æ€»ç»“æ¡†
                                                strcpy(modified_html + before_len, summary_box);
                                                // å¤åˆ¶å‰©ä½™å†…å®¹
                                                strcpy(modified_html + before_len + strlen(summary_box), body_end);
                                                
                                                size_t new_html_len = before_len + strlen(summary_box) + (decompressed_len - before_len);
                                                printf("[Proxy] âœ… å·²åœ¨ <body> åæ’å…¥æ€»ç»“æ¡†\n");
                                                printf("[Proxy] ä¿®æ”¹å HTML é•¿åº¦: %zu å­—èŠ‚\n", new_html_len);
                                                
                                                // === è°ƒè¯•ï¼šä¿å­˜ä¿®æ”¹åçš„ HTMLï¼ˆæœªå‹ç¼©ï¼‰===
                                                time_t now = time(NULL);
                                                struct tm *t = localtime(&now);
                                                char debug_filename[256];
                                                snprintf(debug_filename, sizeof(debug_filename), 
                                                    "output/%04d%02d%02d_%02d%02d%02d_modified.html",
                                                    t->tm_year + 1900, t->tm_mon + 1, t->tm_mday,
                                                    t->tm_hour, t->tm_min, t->tm_sec);
                                                FILE *debug_fp = fopen(debug_filename, "w");
                                                if (debug_fp) {
                                                    fwrite(modified_html, 1, new_html_len, debug_fp);
                                                    fclose(debug_fp);
                                                    printf("[Proxy] ğŸ’¾ å·²ä¿å­˜ä¿®æ”¹åçš„HTML: %s\n", debug_filename);
                                                }
                                                // === è°ƒè¯•ç»“æŸ ===
                                                
                                                // é‡æ–°å‹ç¼©ä¸º gzip
                                                size_t new_compressed_len = 0;
                                                char *new_compressed = compress_gzip(modified_html, new_html_len, &new_compressed_len);
                                                
                                                if (new_compressed && new_compressed_len > 0) {
                                                    printf("[Proxy] âœ… é‡æ–°å‹ç¼©æˆåŠŸï¼Œæ–° gzip é•¿åº¦: %zu å­—èŠ‚\n", new_compressed_len);
                                                    
                                                    // === éªŒè¯å‹ç¼©çš„æ­£ç¡®æ€§ï¼šç«‹å³è§£å‹çœ‹æ˜¯å¦ä¸€è‡´ ===
                                                    size_t verify_len = 0;
                                                    char *verify_decompressed = decompress_gzip(new_compressed, new_compressed_len, &verify_len);
                                                    if (verify_decompressed && verify_len == new_html_len && 
                                                        memcmp(verify_decompressed, modified_html, new_html_len) == 0) {
                                                        printf("[Proxy] âœ… å‹ç¼©éªŒè¯é€šè¿‡ï¼šè§£å‹åä¸åŸå§‹ä¿®æ”¹å†…å®¹å®Œå…¨ä¸€è‡´\n");
                                                    } else {
                                                        printf("[Proxy] âš ï¸  å‹ç¼©éªŒè¯å¤±è´¥ï¼šè§£å‹é•¿åº¦ %zu vs åŸå§‹ %zu\n", verify_len, new_html_len);
                                                    }
                                                    if (verify_decompressed) free(verify_decompressed);
                                                    // === éªŒè¯ç»“æŸ ===
                                                    
                                                    // é‡æ–°æ„é€  HTTP å“åº”
                                                    // éœ€è¦æ›´æ–° Content-Lengthï¼ˆå¦‚æœæœ‰çš„è¯ï¼‰
                                                    char new_response[BUFFER_SIZE];
                                                    char modified_header[MAX_HEADER_SIZE];
                                                    memcpy(modified_header, server_buffer, header_len);
                                                    modified_header[header_len - 4] = '\0'; // å»æ‰ \r\n\r\n
                                                    
                                                    // åˆ é™¤æˆ–æ›´æ–° Content-Length
                                                    char *cl_start = strstr(modified_header, "Content-Length:");
                                                    if (!cl_start) {
                                                        cl_start = strstr(modified_header, "content-length:");
                                                    }
                                                    
                                                    if (cl_start) {
                                                        char *cl_end = strstr(cl_start, "\r\n");
                                                        if (cl_end) {
                                                            // åˆ é™¤æ—§çš„ Content-Length è¡Œ
                                                            memmove(cl_start, cl_end + 2, strlen(cl_end + 2) + 1);
                                                        }
                                                    }
                                                    
                                                    // æ„é€ æ–°å“åº”
                                                    int new_header_len = snprintf(new_response, sizeof(new_response), 
                                                        "%sContent-Length: %zu\r\n\r\n", 
                                                        modified_header, new_compressed_len);
                                                    
                                                    // å¤åˆ¶å‹ç¼©åçš„ body
                                                    if (new_header_len + new_compressed_len < sizeof(new_response)) {
                                                        memcpy(new_response + new_header_len, new_compressed, new_compressed_len);
                                                        len = new_header_len + new_compressed_len;
                                                        memcpy(server_buffer, new_response, len);
                                                        server_buffer[len] = '\0';
                                                        
                                                        printf("[Proxy] âœ… å·²é‡æ–°æ‰“åŒ… HTTP å“åº”ï¼Œæœ€ç»ˆé•¿åº¦: %zu å­—èŠ‚\n", len);
                                                        
                                                        // === è°ƒè¯•ï¼šä¿å­˜æœ€ç»ˆå‘é€ç»™æµè§ˆå™¨çš„å®Œæ•´å“åº”ï¼ˆå« gzip bodyï¼‰===
                                                        char final_filename[256];
                                                        snprintf(final_filename, sizeof(final_filename), 
                                                            "output/%04d%02d%02d_%02d%02d%02d_final_response.bin",
                                                            t->tm_year + 1900, t->tm_mon + 1, t->tm_mday,
                                                            t->tm_hour, t->tm_min, t->tm_sec);
                                                        FILE *final_fp = fopen(final_filename, "wb");
                                                        if (final_fp) {
                                                            fwrite(server_buffer, 1, len, final_fp);
                                                            fclose(final_fp);
                                                            printf("[Proxy] ğŸ’¾ å·²ä¿å­˜æœ€ç»ˆå“åº”: %s\n", final_filename);
                                                        }
                                                        // === è°ƒè¯•ç»“æŸ ===
                                                    }
                                                    
                                                    free(new_compressed);
                                                } else {
                                                    printf("[Proxy] âŒ é‡æ–°å‹ç¼©å¤±è´¥\n");
                                                }
                                                
                                                free(modified_html);
                                            }
                                        } else {
                                            printf("[Proxy] âš ï¸  æœªæ‰¾åˆ° <body> æ ‡ç­¾ï¼Œè·³è¿‡æ’å…¥\n");
                                            free(modified_html);
                                        }
                                    }
                                } else {
                                    printf("[Proxy] âš ï¸  LLM è°ƒç”¨å¤±è´¥\n");
                                }
                                
                                free(decompressed);
                            } else {
                                printf("[Proxy] âŒ gzip è§£å‹å¤±è´¥\n");
                            }
                        }
                        
                        printf("[Proxy] âœ… å¤„ç†å®Œæˆ\n");
                        printf("========================================\n\n");
                        
                        // æ ‡è®°å·²å¤„ç†
                        llm_processed = 1;
                    }
                }
                
                // ================== GZIP + LLM ä¿®æ”¹éƒ¨åˆ†ç»“æŸ ==================

                // ================== TEST æ¨¡å¼ï¼šä»…æ‹¦æˆªã€è§£å‹ã€ä¿å­˜ gzip ==================
                // llm=false æ—¶ï¼Œåªåšä¸€ä»¶äº‹ï¼šæ£€æµ‹ gzip å†…å®¹ï¼Œè§£å‹å¹¶ä¿å­˜ä¸º .txt
                if (!llm_enabled) {
                    static int packet_count = 0;
                    packet_count++;
                    
                    // æ£€æŸ¥æ˜¯å¦æ˜¯HTTPå“åº”çš„å¼€å§‹
                    int is_http_response = (len >= 5 && strncmp(server_buffer, "HTTP/", 5) == 0);
                    
                    if (is_http_response) {
                        printf("[Test Mode] ğŸ“¨ æ•°æ®åŒ… #%d: %zu å­—èŠ‚ [æ–°çš„HTTPå“åº”]\n", packet_count, len);
                        
                        // æ£€æµ‹ gzip å¹¶è§£å‹ä¿å­˜
                        save_html_with_decompression(server_buffer, len);
                    } else {
                        printf("[Test Mode] ğŸ“¦ æ•°æ®åŒ… #%d: %zu å­—èŠ‚ [ç»§ç»­]\n", packet_count, len);
                    }
                }
                // ================== TEST æ¨¡å¼ç»“æŸ ==================
                
                // åŸæœ‰çš„ Header æ³¨å…¥é€»è¾‘ (X-Proxy: CS112)
                // åªæœ‰å½“ buffer å¼€å¤´è¿˜æ˜¯ HTTP/ æ—¶æ‰æ³¨å…¥
                if (first_response && len >= 5 && strncmp(server_buffer, "HTTP/", 5) == 0) {
                    inject_header(server_buffer, &len, sizeof(server_buffer));
                    first_response = 0;  // æ ‡è®°å·²å¤„ç†ï¼Œé¿å…é‡å¤å¤„ç†åç»­æ•°æ®åŒ…
                }

                // å°†æ•°æ®å‘é€å›ç»™å®¢æˆ·ç«¯
                int sent = 0;
                while (sent < (int)len) {
                    int n = SSL_write(client_ssl, server_buffer + sent, len - sent);
                    if (n <= 0) {
                        int err = SSL_get_error(client_ssl, n);
                        if (err != SSL_ERROR_WANT_READ && err != SSL_ERROR_WANT_WRITE) {
                            active = 0;
                            break;
                        }
                    } else {
                        sent += n;
                    }
                }
            }
        }
    }

    // cleanup SSL connections
    SSL_shutdown(client_ssl);
    SSL_free(client_ssl);
    SSL_CTX_free(client_ctx);
    X509_free(cert);
    SSL_shutdown(server_ssl);
    SSL_free(server_ssl);
    SSL_CTX_free(server_ctx);
    close(server_fd);
}

// connect to upstream server
int connect_to_server(const char *hostname, int port) {
    struct hostent *host = gethostbyname(hostname);
    if (!host) {
        return -1;
    }

    int sockfd = socket(AF_INET, SOCK_STREAM, 0);
    if (sockfd < 0) {
        return -1;
    }

    struct timeval timeout;
    timeout.tv_sec = 10;
    timeout.tv_usec = 0;
    setsockopt(sockfd, SOL_SOCKET, SO_RCVTIMEO, &timeout, sizeof(timeout));
    setsockopt(sockfd, SOL_SOCKET, SO_SNDTIMEO, &timeout, sizeof(timeout));

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(port);
    memcpy(&server_addr.sin_addr, host->h_addr_list[0], host->h_length);

    if (connect(sockfd, (struct sockaddr *)&server_addr, sizeof(server_addr)) < 0) {
        close(sockfd);
        return -1;
    }

    return sockfd;
}

// create SSL context for server mode (proxy acts as server to client)
SSL_CTX *create_ssl_context_server(void) {
    SSL_CTX *ctx = SSL_CTX_new(TLS_server_method());
    if (!ctx) {
        return NULL;
    }
    SSL_CTX_set_options(ctx, SSL_OP_NO_SSLv2 | SSL_OP_NO_SSLv3);
    return ctx;
}

// create SSL context for client mode (proxy acts as client to server)
SSL_CTX *create_ssl_context_client(void) {
    SSL_CTX *ctx = SSL_CTX_new(TLS_client_method());
    if (!ctx) {
        return NULL;
    }
    SSL_CTX_set_options(ctx, SSL_OP_NO_SSLv2 | SSL_OP_NO_SSLv3);
    SSL_CTX_set_verify(ctx, SSL_VERIFY_NONE, NULL);
    return ctx;
}

// generate fake certificate for hostname, signed by CA
X509 *generate_cert(const char *hostname) {
    X509 *cert = X509_new();
    if (!cert) {
        fprintf(stderr, "Failed to create X509 certificate\n");
        return NULL;
    }

    if (!X509_set_version(cert, 2)) {
        fprintf(stderr, "Failed to set certificate version\n");
        X509_free(cert);
        return NULL;
    }

    // set serial number based on time and hostname
    unsigned long serial = (unsigned long)time(NULL);
    for (size_t i = 0; hostname[i] != '\0'; i++) {
        serial = serial * 31 + hostname[i];
    }
    ASN1_INTEGER_set(X509_get_serialNumber(cert), serial);

    // set validity: start 1 day in past to handle clock skew, valid for 1 year
    X509_gmtime_adj(X509_get_notBefore(cert), -86400L);
    X509_gmtime_adj(X509_get_notAfter(cert), 31536000L);

    // set certificate subject
    X509_NAME *name = X509_get_subject_name(cert);
    X509_NAME_add_entry_by_txt(name, "C", MBSTRING_ASC, 
                               (unsigned char *)"US", -1, -1, 0);
    X509_NAME_add_entry_by_txt(name, "O", MBSTRING_ASC, 
                               (unsigned char *)"CS112 Proxy", -1, -1, 0);
    X509_NAME_add_entry_by_txt(name, "CN", MBSTRING_ASC, 
                               (unsigned char *)hostname, -1, -1, 0);

    X509_set_issuer_name(cert, X509_get_subject_name(ca_cert));

    // set public key
    if (!X509_set_pubkey(cert, ca_key)) {
        fprintf(stderr, "Failed to set public key\n");
        X509_free(cert);
        return NULL;
    }

    // add X.509 v3 extensions
    X509V3_CTX ctx;
    X509V3_set_ctx_nodb(&ctx);
    X509V3_set_ctx(&ctx, ca_cert, cert, NULL, NULL, 0);
    
    X509_EXTENSION *ext = X509V3_EXT_conf_nid(NULL, &ctx, 
                                              NID_basic_constraints, 
                                              "CA:FALSE");
    if (ext) {
        X509_add_ext(cert, ext, -1);
        X509_EXTENSION_free(ext);
    }

    ext = X509V3_EXT_conf_nid(NULL, &ctx, NID_key_usage, 
                              "digitalSignature,keyEncipherment");
    if (ext) {
        X509_add_ext(cert, ext, -1);
        X509_EXTENSION_free(ext);
    }

    ext = X509V3_EXT_conf_nid(NULL, &ctx, NID_ext_key_usage, 
                              "serverAuth");
    if (ext) {
        X509_add_ext(cert, ext, -1);
        X509_EXTENSION_free(ext);
    }

    // add SAN extension, critical for modern browsers
    char san[512];
    snprintf(san, sizeof(san), "DNS:%s", hostname);
    ext = X509V3_EXT_conf_nid(NULL, &ctx, NID_subject_alt_name, san);
    if (ext) {
        X509_add_ext(cert, ext, -1);
        X509_EXTENSION_free(ext);
    } else {
        fprintf(stderr, "Warning: Failed to add SAN extension for %s\n", hostname);
    }

    // sign the certificate with CA key
    if (!X509_sign(cert, ca_key, EVP_sha256())) {
        fprintf(stderr, "Failed to sign certificate\n");
        ERR_print_errors_fp(stderr);
        X509_free(cert);
        return NULL;
    }

    return cert;
}

// inject X-Proxy:CS112 header into HTTP response
void inject_header(char *response, size_t *response_len, size_t buffer_size) {
    char *header_end = strstr(response, "\r\n");
    if (!header_end) {
        return;
    }

    if (strstr(response, "X-Proxy:")) {
        return;
    }

    const char *new_header = "X-Proxy:CS112\r\n";
    size_t new_header_len = strlen(new_header);
    size_t insert_pos = header_end + 2 - response;

    if (*response_len + new_header_len >= buffer_size) {
        return;
    }

    memmove(response + insert_pos + new_header_len,
            response + insert_pos,
            *response_len - insert_pos);

    memcpy(response + insert_pos, new_header, new_header_len);
    *response_len += new_header_len;
}

// parse hostname and port from Host header
void parse_host_port(char *host_header, char **hostname, int *port) {
    char *colon = strchr(host_header, ':');
    if (colon) {
        *colon = '\0';
        *port = atoi(colon + 1);
    }
}

// Helper function: case-insensitive substring search with length limit
const char* strnstr(const char *haystack, const char *needle, size_t len) {
    size_t needle_len = strlen(needle);
    if (needle_len == 0) return haystack;
    
    for (size_t i = 0; i <= len - needle_len; i++) {
        if (strncasecmp(haystack + i, needle, needle_len) == 0) {
            return haystack + i;
        }
    }
    return NULL;
}

// Decompress gzip data
char* decompress_gzip(const char *compressed_data, size_t compressed_len, size_t *decompressed_len) {
    // Initial buffer size for decompressed data
    size_t buffer_size = compressed_len * 4; // Start with 4x the compressed size
    char *decompressed = malloc(buffer_size);
    if (!decompressed) {
        return NULL;
    }
    
    z_stream strm;
    strm.zalloc = Z_NULL;
    strm.zfree = Z_NULL;
    strm.opaque = Z_NULL;
    strm.avail_in = compressed_len;
    strm.next_in = (Bytef*)compressed_data;
    strm.avail_out = buffer_size;
    strm.next_out = (Bytef*)decompressed;
    
    // Use inflateInit2 with windowBits=15+16 for gzip decoding
    int ret = inflateInit2(&strm, 15 + 16);
    if (ret != Z_OK) {
        free(decompressed);
        return NULL;
    }
    
    // Decompress
    ret = inflate(&strm, Z_FINISH);
    if (ret != Z_STREAM_END) {
        // If buffer was too small, try to expand it
        if (ret == Z_BUF_ERROR || ret == Z_OK) {
            size_t new_size = buffer_size * 2;
            char *new_buffer = realloc(decompressed, new_size);
            if (new_buffer) {
                decompressed = new_buffer;
                buffer_size = new_size;
                strm.avail_out = buffer_size - strm.total_out;
                strm.next_out = (Bytef*)(decompressed + strm.total_out);
                ret = inflate(&strm, Z_FINISH);
            }
        }
        
        if (ret != Z_STREAM_END) {
            inflateEnd(&strm);
            free(decompressed);
            return NULL;
        }
    }
    
    *decompressed_len = strm.total_out;
    inflateEnd(&strm);
    
    return decompressed;
}

// Compress data into gzip format
char* compress_gzip(const char *data, size_t data_len, size_t *compressed_len) {
    // Allocate buffer for compressed data (worst case: input + header)
    size_t buffer_size = data_len + 1024;
    char *compressed = malloc(buffer_size);
    if (!compressed) {
        return NULL;
    }
    
    z_stream strm;
    strm.zalloc = Z_NULL;
    strm.zfree = Z_NULL;
    strm.opaque = Z_NULL;
    strm.avail_in = data_len;
    strm.next_in = (Bytef*)data;
    strm.avail_out = buffer_size;
    strm.next_out = (Bytef*)compressed;
    
    // Use deflateInit2 with windowBits=15+16 for gzip encoding
    int ret = deflateInit2(&strm, Z_DEFAULT_COMPRESSION, Z_DEFLATED, 15 + 16, 8, Z_DEFAULT_STRATEGY);
    if (ret != Z_OK) {
        free(compressed);
        return NULL;
    }
    
    // Compress
    ret = deflate(&strm, Z_FINISH);
    if (ret != Z_STREAM_END) {
        deflateEnd(&strm);
        free(compressed);
        return NULL;
    }
    
    *compressed_len = strm.total_out;
    deflateEnd(&strm);
    
    return compressed;
}

// Process and save ONLY decompressed gzip content as text files
void save_html_with_decompression(const char *raw_content, size_t content_len) {
    printf("[Proxy-Test] ğŸ”§ å¼€å§‹æ‰«æ gzip å†…å®¹ï¼ŒåŸå§‹é•¿åº¦: %zu å­—èŠ‚\n", content_len);
    
    // Create output directory if not exists
    struct stat st = {0};
    if (stat("output", &st) == -1) {
        if (mkdir("output", 0755) == -1) {
            printf("[Proxy-Test] âŒ æ— æ³•åˆ›å»º output ç›®å½•\n");
            return;
        }
    }
    
    // Process the content (may contain multiple HTTP responses)
    const char *current = raw_content;
    size_t remaining = content_len;
    int gzip_count = 0;
    int total_responses = 0;
    
    while (remaining > 0) {
        // Find HTTP response start
        if (remaining < 5 || strncmp(current, "HTTP/", 5) != 0) {
            break;
        }
        
        total_responses++;
        
        // Find header end
        const char *header_end = strstr(current, "\r\n\r\n");
        if (!header_end) {
            break;
        }
        
        size_t header_len = (header_end - current) + 4;
        
        // å®‰å…¨æ£€æŸ¥ï¼šç¡®ä¿ header_len ä¸è¶…è¿‡ remaining
        if (header_len > remaining) {
            break;
        }
        
        const char *body_start = header_end + 4;
        
        // Check Content-Type
        char content_type[256] = {0};
        const char *ct_header = strnstr(current, "content-type:", header_len);
        if (!ct_header) {
            ct_header = strnstr(current, "Content-Type:", header_len);
        }
        if (ct_header && ct_header < header_end) {
            const char *ct_end = strstr(ct_header, "\r\n");
            if (ct_end) {
                size_t ct_len = ct_end - ct_header;
                if (ct_len < sizeof(content_type)) {
                    strncpy(content_type, ct_header, ct_len);
                }
            }
        }
        
        // Check if this response has gzip encoding
        int is_gzipped = 0;
        const char *encoding_header = strnstr(current, "content-encoding:", header_len);
        if (!encoding_header) {
            encoding_header = strnstr(current, "Content-Encoding:", header_len);
        }
        if (encoding_header && encoding_header < header_end) {
            const char *line_end = strstr(encoding_header, "\r\n");
            if (line_end && strstr(encoding_header, "gzip") && strstr(encoding_header, "gzip") < line_end) {
                is_gzipped = 1;
            }
        }
        
        // Find body length (estimate next response or end of data)
        size_t body_len = remaining - header_len;
        const char *next_http = body_start;
        
        // é˜²æ­¢æ•´æ•°ä¸‹æº¢ï¼šåªæœ‰å½“ body_len è¶³å¤Ÿå¤§æ—¶æ‰æœç´¢ä¸‹ä¸€ä¸ªå“åº”
        if (body_len > 10) {
            for (size_t i = 1; i < body_len - 5; i++) {
                if (strncmp(body_start + i, "\r\nHTTP/", 7) == 0 || strncmp(body_start + i, "HTTP/", 5) == 0) {
                    if (strncmp(body_start + i, "\r\nHTTP/", 7) == 0) {
                        body_len = i + 2;
                        next_http = body_start + i + 2;
                    } else {
                        body_len = i;
                        next_http = body_start + i;
                    }
                    break;
                }
            }
        }
        
        // If gzipped, decompress and save to separate .txt file
        if (is_gzipped && body_len > 0) {
            printf("[Proxy-Test] ğŸ“¦ å‘ç° gzip å†…å®¹ (å“åº” #%d)\n", total_responses);
            printf("[Proxy-Test]    Content-Type: %s\n", content_type[0] ? content_type : "(æœªçŸ¥)");
            printf("[Proxy-Test]    å‹ç¼©å¤§å°: %zu å­—èŠ‚\n", body_len);
            
            size_t decompressed_len = 0;
            char *decompressed = decompress_gzip(body_start, body_len, &decompressed_len);
            
            if (decompressed && decompressed_len > 0) {
                gzip_count++;
                
                // Generate unique filename with timestamp
                time_t now = time(NULL);
                struct tm *tm_info = localtime(&now);
                char filename[256];
                snprintf(filename, sizeof(filename), "output/%04d%02d%02d_%02d%02d%02d_gzip%d.txt",
                         tm_info->tm_year + 1900, tm_info->tm_mon + 1, tm_info->tm_mday,
                         tm_info->tm_hour, tm_info->tm_min, tm_info->tm_sec, gzip_count);
                
                FILE *fp = fopen(filename, "w");
                if (fp) {
                    // Write metadata header
                    fprintf(fp, "===== GZIP è§£å‹æµ‹è¯•æ–‡ä»¶ =====\n");
                    fprintf(fp, "å“åº”ç¼–å·: #%d\n", total_responses);
                    fprintf(fp, "Content-Type: %s\n", content_type[0] ? content_type : "(æœªçŸ¥)");
                    fprintf(fp, "å‹ç¼©å‰å¤§å°: %zu å­—èŠ‚\n", body_len);
                    fprintf(fp, "è§£å‹åå¤§å°: %zu å­—èŠ‚\n", decompressed_len);
                    fprintf(fp, "å‹ç¼©æ¯”: %.1f%%\n", (body_len * 100.0) / decompressed_len);
                    fprintf(fp, "=============================\n\n");
                    
                    // Write decompressed content
                    fwrite(decompressed, 1, decompressed_len, fp);
                    fclose(fp);
                    
                    printf("[Proxy-Test] âœ… æˆåŠŸè§£å‹å¹¶ä¿å­˜: %s\n", filename);
                    printf("[Proxy-Test]    è§£å‹åå¤§å°: %zu å­—èŠ‚\n", decompressed_len);
                    printf("[Proxy-Test]    å‹ç¼©æ¯”: %.1f%%\n\n", (body_len * 100.0) / decompressed_len);
                } else {
                    printf("[Proxy-Test] âŒ æ— æ³•åˆ›å»ºæ–‡ä»¶: %s\n", filename);
                }
                
                free(decompressed);
            } else {
                printf("[Proxy-Test] âš ï¸  gzip è§£å‹å¤±è´¥\n\n");
            }
        }
        
        // Move to next response
        size_t processed = header_len + body_len;
        current = next_http;
        remaining -= processed;
    }
    
    printf("[Proxy-Test] ğŸ“Š æ‰«æå®Œæˆ: å…± %d ä¸ªå“åº”, å‘ç°å¹¶è§£å‹ %d ä¸ª gzip å†…å®¹\n", total_responses, gzip_count);
}

// Original save function (kept for backward compatibility)
void save_html_to_file(const char *html_content, size_t content_len) {
    save_html_with_decompression(html_content, content_len);
}

// send HTML content to fake_news.py service and get judgment result
int send_to_fake_news_service(const char *html_content, size_t content_len, char *result_buf, size_t result_buf_size) {
    int sockfd;
    struct sockaddr_in serv_addr;
    const char *service_host = "127.0.0.1";
    int service_port = 5000;
    
    // create socket
    sockfd = socket(AF_INET, SOCK_STREAM, 0);
    if (sockfd < 0) {
        printf("[Proxy] âŒ æ— æ³•åˆ›å»º socket è¿æ¥åˆ° fake_news æœåŠ¡\n");
        return -1;
    }
    
    // set timeout
    struct timeval timeout;
    timeout.tv_sec = 30;
    timeout.tv_usec = 0;
    setsockopt(sockfd, SOL_SOCKET, SO_RCVTIMEO, &timeout, sizeof(timeout));
    setsockopt(sockfd, SOL_SOCKET, SO_SNDTIMEO, &timeout, sizeof(timeout));
    
    // setup server address
    memset(&serv_addr, 0, sizeof(serv_addr));
    serv_addr.sin_family = AF_INET;
    serv_addr.sin_port = htons(service_port);
    
    if (inet_pton(AF_INET, service_host, &serv_addr.sin_addr) <= 0) {
        printf("[Proxy] âŒ æ— æ•ˆçš„æœåŠ¡åœ°å€\n");
        close(sockfd);
        return -1;
    }
    
    // connect to service
    printf("[Proxy] ğŸ”— æ­£åœ¨è¿æ¥ fake_news æœåŠ¡ (%s:%d)...\n", service_host, service_port);
    if (connect(sockfd, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0) {
        printf("[Proxy] âŒ è¿æ¥å¤±è´¥ (æœåŠ¡å¯èƒ½æœªå¯åŠ¨)\n");
        close(sockfd);
        return -1;
    }
    printf("[Proxy] âœ… å·²è¿æ¥åˆ° fake_news æœåŠ¡\n");
    
    // send HTML content
    printf("[Proxy] ğŸ“¤ æ­£åœ¨å‘é€ HTML å†…å®¹ (%zu å­—èŠ‚)...\n", content_len);
    size_t total_sent = 0;
    while (total_sent < content_len) {
        ssize_t sent = send(sockfd, html_content + total_sent, content_len - total_sent, 0);
        if (sent < 0) {
            printf("[Proxy] âŒ å‘é€æ•°æ®å¤±è´¥\n");
            close(sockfd);
            return -1;
        }
        total_sent += sent;
    }
    
    // send end marker
    const char *end_marker = "\n\n__END__\n\n";
    send(sockfd, end_marker, strlen(end_marker), 0);
    
    // shutdown write side to signal end of transmission
    shutdown(sockfd, SHUT_WR);
    printf("[Proxy] âœ… HTML å†…å®¹å‘é€å®Œæˆï¼ˆå·²å…³é—­å‘é€é€šé“ï¼‰\n");
    
    // receive response
    printf("[Proxy] ğŸ“¥ ç­‰å¾… fake_news æœåŠ¡è¿”å›ç»“æœ...\n");
    memset(result_buf, 0, result_buf_size);
    ssize_t received = recv(sockfd, result_buf, result_buf_size - 1, 0);
    if (received <= 0) {
        printf("[Proxy] âŒ æ¥æ”¶å“åº”å¤±è´¥\n");
        close(sockfd);
        return -1;
    }
    
    result_buf[received] = '\0';
    
    // remove newline
    char *newline = strchr(result_buf, '\n');
    if (newline) *newline = '\0';
    
    printf("[Proxy] âœ… æ”¶åˆ°åˆ¤æ–­ç»“æœ: %s\n", result_buf);
    
    close(sockfd);
    return 0;
}

